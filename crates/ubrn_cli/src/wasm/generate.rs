/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/
 */

use anyhow::Result;
use camino::Utf8PathBuf;
use clap::{Args, Subcommand};
use ubrn_bindgen::{ModuleMetadata, OutputArgs, SourceArgs, SwitchArgs};

use crate::{codegen::render_files, ProjectConfig};

#[derive(Args, Debug)]
pub(crate) struct CmdArg {
    #[clap(subcommand)]
    cmd: Cmd,
}
impl CmdArg {
    pub(crate) fn run(&self) -> Result<()> {
        self.cmd.run()
    }
}

#[derive(Debug, Subcommand)]
enum Cmd {
    /// Generate just the Typescript and wasm-bindgen bindings
    Bindings(BindingsArgs),

    /// wasm-bindgen crate
    WasmCrate(WasmCrateArgs),
}

impl Cmd {
    fn run(&self) -> Result<()> {
        match self {
            Self::Bindings(b) => {
                let b = ubrn_bindgen::BindingsArgs::from(b);
                b.run(None)?;
                Ok(())
            }
            Self::WasmCrate(c) => {
                c.run()?;
                Ok(())
            }
        }
    }
}

#[derive(Args, Debug)]
struct BindingsArgs {
    #[command(flatten)]
    pub(crate) source: SourceArgs,
    #[command(flatten)]
    pub(crate) output: OutputArgs,
}

impl From<&BindingsArgs> for ubrn_bindgen::BindingsArgs {
    fn from(value: &BindingsArgs) -> Self {
        ubrn_bindgen::BindingsArgs::new(
            SwitchArgs {
                flavor: ubrn_bindgen::AbiFlavor::Wasm,
            },
            value.source.clone(),
            value.output.clone(),
        )
    }
}

#[derive(Args, Debug)]
pub(crate) struct WasmCrateArgs {
    /// The configuration file for this build
    #[clap(long)]
    config: Utf8PathBuf,

    /// The namespaces that are generated by `generate bindings`.
    namespaces: Vec<String>,
}

impl WasmCrateArgs {
    pub(crate) fn run(&self) -> Result<()> {
        let project = ProjectConfig::try_from(self.config.clone())?;
        let modules = self
            .namespaces
            .iter()
            .map(|s| ModuleMetadata::new(s))
            .collect();
        let rust_crate = project.crate_.metadata()?;
        render_files(Some(crate::Platform::Wasm), project, rust_crate, modules)?;
        Ok(())
    }
}
