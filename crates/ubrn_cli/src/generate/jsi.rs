/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/
 */

use anyhow::Result;
use camino::Utf8PathBuf;
use clap::{Args, Subcommand};
use ubrn_bindgen::{ModuleMetadata, OutputArgs, SourceArgs, SwitchArgs};

use crate::{codegen::render_files, ProjectConfig};

#[derive(Args, Debug)]
pub(crate) struct CmdArg {
    #[clap(subcommand)]
    cmd: Cmd,
}
impl CmdArg {
    pub(crate) fn run(&self) -> Result<()> {
        self.cmd.run()
    }
}

#[derive(Debug, Subcommand)]
enum Cmd {
    /// Generate the TurboModule code to plug the bindings into the app
    TurboModule(TurboModuleArgs),
    /// Generate just the Typescript and C++ bindings
    Bindings(BindingsArgs),
}

impl Cmd {
    fn run(&self) -> Result<()> {
        match self {
            Self::Bindings(b) => {
                let b = ubrn_bindgen::BindingsArgs::from(b);
                b.run(None)?;
                Ok(())
            }
            Self::TurboModule(t) => {
                t.run()?;
                Ok(())
            }
        }
    }
}

#[derive(Args, Debug)]
pub(crate) struct BindingsArgs {
    #[command(flatten)]
    pub(crate) source: SourceArgs,
    #[command(flatten)]
    pub(crate) output: OutputArgs,
}

impl From<&BindingsArgs> for ubrn_bindgen::BindingsArgs {
    fn from(value: &BindingsArgs) -> Self {
        ubrn_bindgen::BindingsArgs::new(
            SwitchArgs::default(),
            value.source.clone(),
            value.output.clone(),
        )
    }
}

#[derive(Args, Debug)]
pub(crate) struct TurboModuleArgs {
    /// The configuration file for this build
    #[clap(long)]
    config: Utf8PathBuf,

    /// The namespaces that are generated by `generate bindings`.
    namespaces: Vec<String>,
}

impl TurboModuleArgs {
    pub(crate) fn run(&self) -> Result<()> {
        let project = ProjectConfig::try_from(self.config.clone())?;
        let modules = self
            .namespaces
            .iter()
            .map(|s| ModuleMetadata::new(s))
            .collect();
        let rust_crate = project.crate_.metadata()?;
        render_files(None, project, rust_crate, modules)?;
        Ok(())
    }
}
