// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

import NativeModule from "./{{ config.ffi_ts_filename }}";

{%- for entry in self.type_imports.borrow() %}
{%-   let file = entry.0 %}
{%-   let things = entry.1 %}
import {
{%-   for thing in things %}
{%-     match thing %}
{%-       when Imported::TSType with (type_) %}
  type {{ type_ }}
{%-       when Imported::JSType with (type_) %}
  {{ type_ }}
{%-     endmatch %}
{%-     if !loop.last %}, {% endif %}
{%-   endfor %} } from "{{ file }}";
{%- endfor %}

// Get converters from the other files, if any.
{%- for entry in self.imported_converters.borrow() %}
{%-   let uniffiConverters = entry.0 %}
{%-   let converters = entry.1 %}
const {
{%-   for converter in converters %}
        {{- converter }},
{%-   endfor %}
} = {{ uniffiConverters }};
{%- endfor %}

{%- call ts::docstring_value(ci.namespace_docstring(), 0) %}

{%- import "macros.ts" as ts %}

{#
// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport({{ config.ffi_module_name() }})
import {{ config.ffi_module_name() }}
#endif
#}

{% include "Helpers.ts" %}
{% include "HandleMap.ts" %}

// Public interface members begin here.
{{ type_helper_code }}

{% if !self.exported_converters.is_empty() %}
export const uniffiConverters = Object.freeze({
  {%- for converter in self.exported_converters.borrow() %}
  {{ converter }},
  {%- endfor %}
});
{% endif %}
