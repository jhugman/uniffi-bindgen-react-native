// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
{%- let namespace = ci.namespace() %}
{%- let module_name = module.cpp_module() %}
{%- let registry = ci.cpp_namespace()|fmt("{}::registry") %}
#include "{{ module.hpp_filename() }}"

#include "UniffiJsiTypes.h"
#include <stdexcept>
#include <map>
#include <utility>
#include <iostream>
#include <thread>

namespace react = facebook::react;
namespace jsi = facebook::jsi;

// Calling into Rust.
extern "C" {
    {%- for definition in ci.ffi_definitions() %}
    {%- match definition %}
    {%- when FfiDefinition::Struct(ffi_struct) %}
    {%- call cpp::callback_struct_decl(ffi_struct) %}
    {%- when FfiDefinition::CallbackFunction(callback) %}
    {%- call cpp::callback_fn_decl(callback) %}
    {%- when FfiDefinition::Function with(func) %}
    {% call cpp::rust_fn_decl(func) %}
    {%- else %}
    {%- endmatch %}
    {%- endfor %}
}

{% include "BridgingHelper.cpp" %}
{% include "RustBufferHelper.cpp" %}
{% include "RustCallStatusHelper.cpp" %}
{% include "VTableRegistryHelper.cpp" %}

// This calls into Rust.

{%- for def in ci.ffi_definitions() %}
{%-   match def %}
{%-     when FfiDefinition::CallbackFunction(callback) %}
{%-       if callback.is_rust_calling_js() %}
{%-         if callback.is_free_callback() %}
    // Implementation of free callback function {{ callback.name() }}
{%            call cpp::callback_fn_free_impl(callback) %}
{%-         else %}
{%-           if !callback.is_user_callback() %}
    // Implementation of callback function calling from Rust to JS {{ callback.name() }}
{%-             call cpp::callback_fn_impl(callback) %}
{%-           endif %}
{%-         endif %}
{%-       else %}
    // Implementation of callback function calling from JS to Rust {{ callback.name() }},
    // passed from Rust to JS as part of async callbacks.
{%-         include "ForeignFuture.cpp" %}
{%-       endif %}
{%-     when FfiDefinition::Struct(ffi_struct) %}
{%-       if ffi_struct.is_vtable() %}
{%-         for field in ffi_struct.ffi_functions() %}
{%-           if field.is_user_callback() %}
{%-             if let Some(callback) = field.callback_function(ci) %}
    // Implementation of {{ callback.name() }} for vtable field {{ field.name() }} in {{ ffi_struct.name() }}
{%-               let ns = field.cpp_namespace_in_struct(ci, ffi_struct.name()) %}
{%                include "CallbackFunction.cpp" %}
{%-             endif %}
{%-           endif %}
{%-         endfor %}
{%-       endif %}
{%-       include "Struct.cpp" %}
{%-     else %}
{%-   endmatch %}
{%- endfor %}

{% include "Future.cpp" %}

{{ module_name }}::{{ module_name }}(
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> invoker
) : callInvoker(invoker), props() {
    // Map from Javascript names to the cpp names
    {%- for func in ci.iter_ffi_functions_js_to_cpp() %}
    {%- let name = func.name()|fmt("ubrn_{}") %}
    props["{{ name }}"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "{{ name }}"),
        {{ func.arguments().len() }},
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->{% call cpp::cpp_func_name(func) %}(rt, thisVal, args, count);
        }
    );
    {%- endfor %}
}

void {{ module_name }}::registerModule(jsi::Runtime &rt, std::shared_ptr<react::CallInvoker> callInvoker) {
    auto invoker = std::make_shared<uniffi_runtime::UniffiCallInvoker>(callInvoker);
    auto tm = std::make_shared<{{ module_name }}>(rt, invoker);
    auto obj = rt.global().createFromHostObject(rt, tm);
    rt.global().setProperty(rt, "{{ module_name }}", obj);
}

void {{ module_name }}::unregisterModule(jsi::Runtime &rt) {
    {{ registry }}::clearRegistry();
}

jsi::Value {{ module_name }}::get(jsi::Runtime& rt, const jsi::PropNameID& name) {
    try {
        return jsi::Value(rt, props.at(name.utf8(rt)));
    }
    catch (std::out_of_range &e) {
        return jsi::Value::undefined();
    }
}

std::vector<jsi::PropNameID> {{ module_name }}::getPropertyNames(jsi::Runtime& rt) {
    std::vector<jsi::PropNameID> rval;
    for (auto& [key, value] : props) {
        rval.push_back(jsi::PropNameID::forUtf8(rt, key));
    }
    return rval;
}

void {{ module_name }}::set(jsi::Runtime& rt, const jsi::PropNameID& name, const jsi::Value& value) {
    props.insert_or_assign(name.utf8(rt), &value);
}

{{ module_name }}::~{{ module_name }}() {
{%- for def in ci.ffi_definitions() %}
{%-   match def %}
{%-     when FfiDefinition::CallbackFunction(callback) %}
{%-       if callback.is_rust_calling_js() %}
{%-         if callback.is_free_callback() %}
    // Cleanup for "free" callback function {{ callback.name() }}
{%            call cpp::callback_fn_free_cleanup(callback) %}
{%-         else %}
{%-           if !callback.is_user_callback() %}
    // Cleanup for callback function {{ callback.name() }}
{%              call cpp::callback_fn_cleanup(callback) %}
{%-           endif %}
{%-         endif %}
{%-       endif %}
{%-     when FfiDefinition::Struct(ffi_struct) %}
{%-       if ffi_struct.is_vtable() %}
{%-         for field in ffi_struct.ffi_functions() %}
{%-           if field.is_user_callback() %}
{%              call cpp::callback_fn_vtable_field_cleanup(ffi_struct, field) %}
{%-           endif %}
{%-         endfor %}
{%-       endif %}
{%-     else %}
{%-   endmatch %}
{%- endfor %}
}

{%- include "StringHelper.cpp" %}
{%- include "ObjectHelper.cpp" %}

// Methods calling directly into the uniffi generated C API of the Rust crate.
{%- for func in ci.iter_ffi_functions_js_to_rust() %}
{%-   if func.is_callback_init() %}
{%      call cpp::callback_init(module_name, func) %}
{%-   else %}
{%      call cpp::rust_fn_caller(module_name, func) %}
{%-   endif %}
{%- endfor %}

{%- import "macros.cpp" as cpp %}
