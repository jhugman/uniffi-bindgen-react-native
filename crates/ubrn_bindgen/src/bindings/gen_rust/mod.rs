/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/
 */
mod config;

use anyhow::Result;
use proc_macro2::{Span, TokenStream};
use quote::quote;
use syn::Ident;
use uniffi_bindgen::{
    interface::{FfiArgument, FfiCallbackFunction, FfiDefinition, FfiFunction, FfiStruct, FfiType},
    ComponentInterface,
};

use crate::{
    bindings::{
        extensions::{ComponentInterfaceExt, FfiFunctionExt},
        metadata::ModuleMetadata,
    },
    switches::SwitchArgs,
    AbiFlavor,
};
pub(crate) use config::RustConfig as Config;

#[allow(unused_variables)]
pub(crate) fn generate_rs(
    ci: &ComponentInterface,
    module: &ModuleMetadata,
    config: &Config,
    switches: &SwitchArgs,
    try_format_code: bool,
) -> Result<String> {
    let mut template = ComponentTemplate::new(config, switches);
    let output: TokenStream = template.ci(ci);
    let code = formatted(output, try_format_code)?;
    Ok(code)
}

pub(crate) fn generate_entrypoint(modules: &[ModuleMetadata]) -> Result<String> {
    let prelude = entrypoint_prelude();
    let mods: TokenStream = modules
        .iter()
        .map(|m| {
            let namespace = Ident::new(&m.namespace, Span::call_site());
            quote! { mod #namespace; }
        })
        .collect();
    let src = quote! {
        #prelude

        #mods
    };
    formatted(src, true)
}

fn entrypoint_prelude() -> TokenStream {
    quote! {
        // Generated by uniffi-bindgen-react-native. Now with generating rust
    }
}

fn formatted(tokens: TokenStream, try_format_code: bool) -> Result<String> {
    let code = if try_format_code {
        let syntax_tree = syn::parse2(tokens)?;
        prettyplease::unparse(&syntax_tree)
    } else {
        TokenStream::to_string(&tokens)
    };
    Ok(code)
}

struct FlavorParams<'a> {
    runtime_module: &'a str,
}

impl FlavorParams<'_> {
    fn runtime_module(&self) -> Ident {
        ident(self.runtime_module)
    }

    fn foreign_ident(&self, suffix: &str) -> Ident {
        ident(&format!("ubrn_{suffix}"))
    }
}

fn ident(id: &str) -> Ident {
    Ident::new(id, Span::call_site())
}

fn wasm_flavor() -> FlavorParams<'static> {
    FlavorParams {
        runtime_module: "uniffi_wasm",
    }
}

impl From<&AbiFlavor> for FlavorParams<'_> {
    fn from(value: &AbiFlavor) -> Self {
        match value {
            AbiFlavor::Jsi => unreachable!("Jsi should be only generating C++ not Rust"),
            AbiFlavor::Wasm => wasm_flavor(),
        }
    }
}

#[allow(dead_code)]
struct GeneratorParams<'params> {
    config: &'params Config,
    switches: &'params SwitchArgs,
}

impl<'params> GeneratorParams<'params> {
    fn new(config: &'params Config, switches: &'params SwitchArgs) -> Self {
        Self { config, switches }
    }
}

#[derive(Debug, Default)]
struct GeneratorState;

#[allow(dead_code)]
struct ComponentTemplate<'a> {
    state: GeneratorState,
    params: GeneratorParams<'a>,
    flavor: FlavorParams<'a>,
}

impl<'a> ComponentTemplate<'a> {
    fn new(config: &'a Config, switches: &'a SwitchArgs) -> Self {
        let params = GeneratorParams::new(config, switches);
        let state = GeneratorState;
        let flavor = FlavorParams::from(&switches.flavor);
        Self {
            params,
            state,
            flavor,
        }
    }

    fn ci(&mut self, ci: &ComponentInterface) -> TokenStream {
        let prelude = self.prelude(ci);

        // let definitions: TokenStream = ci
        //     .ffi_definitions()
        //     .map(|f| self.ffi_definition(&f))
        //     .collect();

        let definitions: TokenStream = ci
            .iter_ffi_functions_js_to_rust()
            .map(|f| self.ffi_function(&f))
            .collect();

        quote! {
            // Generated by uniffi-bindgen-react-native
            #prelude

            #definitions
        }
    }

    fn runtime_ident(&self) -> Ident {
        ident("f")
    }

    fn module_ident(&self) -> Ident {
        ident("r")
    }

    fn uniffi_ident(&self) -> Ident {
        ident("u")
    }

    fn prelude(&self, ci: &ComponentInterface) -> TokenStream {
        let runtime_alias_ident = self.runtime_ident();
        let runtime_ident = self.flavor.runtime_module();
        let namespace_ident = ident(ci.namespace());
        let module_ident = self.module_ident();
        let uniffi_alias_ident = self.uniffi_ident();
        quote! {
            use #runtime_ident::{self as #runtime_alias_ident, uniffi as #uniffi_alias_ident, IntoRust};
            use #namespace_ident as #module_ident;
        }
    }

    #[allow(dead_code)]
    fn ffi_definition(&mut self, definition: &FfiDefinition) -> TokenStream {
        match definition {
            FfiDefinition::Function(f) => self.ffi_function(f),
            FfiDefinition::CallbackFunction(cb) => self.ffi_callback(cb),
            FfiDefinition::Struct(s) => self.ffi_struct(s),
        }
    }

    fn ffi_function(&mut self, func: &FfiFunction) -> TokenStream {
        let module = self.module_ident();
        let runtime = self.runtime_ident();
        let uniffi = self.uniffi_ident();

        let annotation = quote! { #[#runtime::export] };
        let func_ident = ident(func.name());
        let foreign_func_ident = self.flavor.foreign_ident(func.name());

        let args = func.arguments();
        let args_decl: TokenStream = args.iter().map(|arg| self.arg_decl(arg)).collect();
        let args_call: TokenStream = args.iter().map(|arg| self.arg_to_rust(arg)).collect();

        let has_return = func.return_type().is_some();

        let decl_suffix = if let Some(type_) = func.return_type() {
            let return_type = self.ffi_type_foreign(type_);
            quote! { -> #return_type }
        } else {
            quote! {}
        };

        let needs_call_status = func.has_rust_call_status_arg();
        if needs_call_status {
            let rust_status_ident = ident("u_status_");
            let foreign_status_ident = ident("f_status_");
            let return_ident = ident("value_");
            let let_value = if has_return {
                quote! { let #return_ident = }
            } else {
                quote! {}
            };
            let return_value = if has_return {
                quote! { #return_ident }
            } else {
                quote! {}
            };
            let call_suffix = if has_return {
                quote! { .into_js() }
            } else {
                quote! {}
            };
            let unsafe_ = if func.is_unsafe() {
                quote! { unsafe }
            } else {
                quote! {}
            };

            quote! {
                #annotation
                pub #unsafe_ fn #foreign_func_ident(#args_decl #foreign_status_ident: &mut #runtime::RustCallStatus) #decl_suffix {
                    let mut #rust_status_ident = #uniffi::RustCallStatus::default();
                    #let_value #module::#func_ident(#args_call &mut #rust_status_ident) #call_suffix;
                    #foreign_status_ident.copy_into(#rust_status_ident);
                    #return_value
                }
            }
        } else {
            let call_suffix = if has_return {
                quote! { .into_js() }
            } else {
                quote! { ; }
            };
            quote! {
                #annotation
                pub fn #foreign_func_ident(#args_decl) #decl_suffix {
                    #module::#func_ident(#args_call) #call_suffix
                }
            }
        }
    }

    #[allow(dead_code)]
    fn ffi_callback(&mut self, _cb: &FfiCallbackFunction) -> TokenStream {
        quote! { /* TODO ffi_callback */}
    }

    #[allow(dead_code)]
    fn ffi_struct(&self, _s: &FfiStruct) -> TokenStream {
        quote! { /* TODO ffi_struct */}
    }

    fn arg_decl(&self, arg: &FfiArgument) -> TokenStream {
        let ident = self.arg_ident(arg);
        let typ = self.ffi_type_foreign(&arg.type_());
        quote! { #ident: #typ, }
    }

    fn arg_to_rust(&self, arg: &FfiArgument) -> TokenStream {
        let ident = self.arg_ident(arg);
        let rust_type = self.ffi_type_rust(&arg.type_());
        quote! { #rust_type::into_rust(#ident), }
    }

    fn arg_ident(&self, arg: &FfiArgument) -> Ident {
        ident(arg.name())
    }

    fn ffi_type_foreign(&self, t: &FfiType) -> TokenStream {
        let runtime = self.runtime_ident();
        let module = self.module_ident();
        match t {
            FfiType::UInt8 => quote! { #runtime::UInt8 },
            FfiType::Int8 => quote! { #runtime::Int8 },
            FfiType::UInt16 => quote! { #runtime::UInt16 },
            FfiType::Int16 => quote! { #runtime::Int16 },
            FfiType::UInt32 => quote! { #runtime::UInt32 },
            FfiType::Int32 => quote! { #runtime::Int32 },
            FfiType::UInt64 => quote! { #runtime::UInt64 },
            FfiType::Int64 => quote! { #runtime::Int64 },
            FfiType::Float32 => quote! { #runtime::Float32 },
            FfiType::Float64 => quote! { #runtime::Float64 },
            FfiType::RustArcPtr(_) => quote! { #runtime::VoidPointer },
            FfiType::RustBuffer(_) => quote! { #runtime::ForeignBytes },
            FfiType::ForeignBytes => quote! { #runtime::ForeignBytes },
            FfiType::Callback(_) => quote! { #module::Callback },
            FfiType::Struct(_) => quote! { #module::Struct },
            FfiType::Handle => quote! { #module::Handle },
            FfiType::RustCallStatus => quote! { #runtime::RustCallStatus },
            FfiType::Reference(_ffi_type) => todo!(),
            FfiType::VoidPointer => quote! { #runtime::VoidPointer },
        }
    }

    fn ffi_type_rust(&self, t: &FfiType) -> TokenStream {
        let uniffi = self.uniffi_ident();
        match t {
            FfiType::UInt8 => quote! { u8 },
            FfiType::Int8 => quote! { i8 },
            FfiType::UInt16 => quote! { u16 },
            FfiType::Int16 => quote! { i16 },
            FfiType::UInt32 => quote! { u32 },
            FfiType::Int32 => quote! { i32 },
            FfiType::UInt64 => quote! { u64 },
            FfiType::Int64 => quote! { i64 },
            FfiType::Float32 => quote! { f32 },
            FfiType::Float64 => quote! { f64 },
            FfiType::RustBuffer(_) => quote! { #uniffi::RustBuffer },
            FfiType::RustArcPtr(_) => quote! { #uniffi::VoidPointer },
            _ => todo!(),
        }
    }
}

#[cfg(test)]
mod unit_tests {
    use uniffi_bindgen::interface::{FfiArgument, FfiFunction, FfiType};

    use super::*;

    fn subject<'component>() -> ComponentTemplate<'component> {
        ComponentTemplate::new(
            &Config {},
            &SwitchArgs {
                flavor: crate::AbiFlavor::Wasm,
            },
        )
    }

    fn arg(name: &str, type_: FfiType) -> FfiArgument {
        FfiArgument::new(name, type_)
    }

    fn no_args() -> impl Iterator<Item = FfiArgument> {
        let args = Vec::new();
        args.into_iter()
    }

    fn void() -> Option<FfiType> {
        None
    }

    fn return_(type_: FfiType) -> Option<FfiType> {
        Some(type_)
    }

    fn func(
        nm: &str,
        args: impl Iterator<Item = FfiArgument>,
        return_: Option<FfiType>,
    ) -> FfiFunction {
        let mut func = FfiFunction::default();
        func.init(return_, args);
        func.rename(nm.to_owned());
        func
    }

    fn trim_indent(input: &str) -> String {
        let lines: Vec<&str> = input.lines().collect();
        let non_empty_lines: Vec<&str> = lines
            .iter()
            .skip_while(|&&line| line.trim().is_empty())
            .cloned()
            .collect::<Vec<&str>>()
            .into_iter()
            .rev()
            .skip_while(|line| line.trim().is_empty())
            .collect::<Vec<&str>>()
            .into_iter()
            .rev()
            .collect();

        let min_indent = non_empty_lines
            .iter()
            .filter(|line| !line.trim().is_empty())
            .map(|line| line.chars().take_while(|c| c.is_whitespace()).count())
            .min()
            .unwrap_or(0);

        non_empty_lines
            .iter()
            .map(|line| {
                if line.trim().is_empty() {
                    line.to_string()
                } else {
                    line.chars().skip(min_indent).collect()
                }
            })
            .collect::<Vec<String>>()
            .join("\n")
    }

    #[test]
    fn happy_path() -> Result<()> {
        let mut subject = subject();
        let input = func("my_function", no_args(), return_(FfiType::Int8));
        let output = subject.ffi_function(&input);
        let string = formatted(output, true)?;

        assert_eq!(
            string.trim(),
            trim_indent(
                "
            #[f::export]
            pub fn ubrn_my_function(f_status_: &mut f::RustCallStatus) -> f::Int8 {
                let mut u_status_ = u::RustCallStatus::default();
                let value_ = r::my_function(&mut u_status_).into_js();
                f_status_.copy_into(u_status_);
                value_
            }
            "
            )
        );
        Ok(())
    }

    #[test]
    fn one_arg() -> Result<()> {
        let mut subject = subject();

        let input = func(
            "my_function",
            vec![arg("num", FfiType::Int32)].into_iter(),
            return_(FfiType::Int8),
        );
        let output = subject.ffi_function(&input);
        let string = formatted(output, true)?;
        assert_eq!(
            string.trim(),
            trim_indent(
                "
            #[f::export]
            pub fn ubrn_my_function(num: f::Int32, f_status_: &mut f::RustCallStatus) -> f::Int8 {
                let mut u_status_ = u::RustCallStatus::default();
                let value_ = r::my_function(i32::into_rust(num), &mut u_status_).into_js();
                f_status_.copy_into(u_status_);
                value_
            }
            "
            )
        );
        Ok(())
    }

    #[test]
    fn two_args() -> Result<()> {
        let mut subject = subject();

        let input = func(
            "my_function",
            vec![arg("left", FfiType::Int32), arg("right", FfiType::Float32)].into_iter(),
            return_(FfiType::Int8),
        );
        let output = subject.ffi_function(&input);
        let string = formatted(output, true)?;
        assert_eq!(
            string.trim(),
            trim_indent(
                "
                #[f::export]
                pub fn ubrn_my_function(
                    left: f::Int32,
                    right: f::Float32,
                    f_status_: &mut f::RustCallStatus,
                ) -> f::Int8 {
                    let mut u_status_ = u::RustCallStatus::default();
                    let value_ = r::my_function(
                            i32::into_rust(left),
                            f32::into_rust(right),
                            &mut u_status_,
                        )
                        .into_js();
                    f_status_.copy_into(u_status_);
                    value_
                }"
            )
        );
        Ok(())
    }

    #[test]
    fn void_return() -> Result<()> {
        let mut subject = subject();

        let input = func("my_function", no_args(), void());
        let output = subject.ffi_function(&input);
        let string = formatted(output, true)?;
        assert_eq!(
            string.trim(),
            trim_indent(
                "
            #[f::export]
            pub fn ubrn_my_function(f_status_: &mut f::RustCallStatus) {
                let mut u_status_ = u::RustCallStatus::default();
                r::my_function(&mut u_status_);
                f_status_.copy_into(u_status_);
            }
            "
            )
        );
        Ok(())
    }
}
