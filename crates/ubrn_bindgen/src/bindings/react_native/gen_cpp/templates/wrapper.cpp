{%- let namespace = ci.namespace() %}
{%- let module_name = module.cpp_module() %}
// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
#include "{{ module.hpp_filename() }}"

#include "UniffiJsiTypes.h"
#include <stdexcept>
#include <map>
#include <utility>
#include <iostream>
#include <thread>

namespace react = facebook::react;
namespace jsi = facebook::jsi;

#ifdef UNIFFI_ENABLE_TEST_HOOKS
// Initialization into the Hermes Runtime
#include "registerNatives.h"
extern "C" void registerNatives(jsi::Runtime &rt, std::shared_ptr<react::CallInvoker> callInvoker) {
    {{ module_name }}::registerModule(rt, callInvoker);
}
#endif

// Calling into Rust.
extern "C" {
    {%- for definition in ci.ffi_definitions() %}
    {%- match definition %}
    {%- when FfiDefinition::Struct(ffi_struct) %}
    {%- call cpp::callback_struct_decl(ffi_struct) %}
    {%- when FfiDefinition::CallbackFunction(callback) %}
    {%- call cpp::callback_fn_decl(callback) %}
    {%- when FfiDefinition::Function with(func) %}
    {% call cpp::rust_fn_decl(func) %}
    {%- else %}
    {%- endmatch %}
    {%- endfor %}
}

// This calls into Rust.

{% include "BridgingHelper.cpp" %}
{% include "RustBufferHelper.cpp" %}
{% include "RustCallStatusHelper.cpp" %}

{%- for def in ci.ffi_definitions() %}
{%-   match def %}
{%-     when FfiDefinition::CallbackFunction(callback) %}
{%-       if callback.is_rust_calling_js() %}
{%-         if callback.is_free_callback() %}
    // Implementation of free callback function {{ callback.name() }}
{%-           call cpp::callback_fn_impl(callback) %}
{%-           call cpp::callback_fn_free_impl(callback) %}
{%-         else %}
    // Implementation of callback function calling from Rust to JS {{ callback.name() }}
{%-           call cpp::callback_fn_impl(callback) %}
{%-         endif %}
{%-       else %}
    // Implementation of callback function calling from JS to Rust {{ callback.name() }},
    // passed from Rust to JS as part of async callbacks.
{%-         include "ForeignFuture.cpp" %}
{%-       endif %}
{%-     when FfiDefinition::Struct(ffi_struct) %}
{%-       include "Struct.cpp" %}
{%-     else %}
{%-   endmatch %}
{%- endfor %}

{% include "Future.cpp" %}

{{ module_name }}::{{ module_name }}(
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> invoker
) : props(), callInvoker(invoker) {
    // Map from Javascript names to the cpp names
    {%- for func in ci.iter_ffi_functions_js_to_cpp() %}
    {%- let name = func.name() %}
    props["{{ name }}"] = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "{{ name }}"),
        {{ func.arguments().len() }},
        [this](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value {
            return this->{% call cpp::cpp_func_name(func) %}(rt, thisVal, args, count);
        }
    );
    {%- endfor %}
}

void {{ module_name }}::registerModule(jsi::Runtime &rt, std::shared_ptr<react::CallInvoker> callInvoker) {
    auto invoker = std::make_shared<uniffi_runtime::UniffiCallInvoker>(callInvoker);
    auto tm = std::make_shared<{{ module_name }}>(rt, invoker);
    auto obj = rt.global().createFromHostObject(rt, tm);
    rt.global().setProperty(rt, "{{ module_name }}", obj);
}

void {{ module_name }}::unregisterModule(jsi::Runtime &rt) {
    // NOOP
}

jsi::Value {{ module_name }}::get(jsi::Runtime& rt, const jsi::PropNameID& name) {
    try {
        return jsi::Value(rt, props.at(name.utf8(rt)));
    }
    catch (std::out_of_range e) {
        return jsi::Value::undefined();
    }
}

std::vector<jsi::PropNameID> {{ module_name }}::getPropertyNames(jsi::Runtime& rt) {
    std::vector<jsi::PropNameID> rval;
    for (auto& [key, value] : props) {
        rval.push_back(jsi::PropNameID::forUtf8(rt, key));
    }
    return rval;
}

void {{ module_name }}::set(jsi::Runtime& rt, const jsi::PropNameID& name, const jsi::Value& value) {
    props.insert_or_assign(name.utf8(rt), &value);
}

{{ module_name }}::~{{ module_name }}() {
{%- for def in ci.ffi_definitions() %}
{%-   match def %}
{%-     when FfiDefinition::CallbackFunction(callback) %}
{%-       if callback.is_rust_calling_js() %}
{%-         if callback.is_free_callback() %}
    // Cleanup for "free" callback function {{ callback.name() }}
{%            call cpp::callback_fn_cleanup(callback) %}
{%            call cpp::callback_fn_free_cleanup(callback) %}
{%-         else %}
    // Cleanup for callback function {{ callback.name() }}
{%            call cpp::callback_fn_cleanup(callback) %}
{%-         endif %}
{%-       endif %}
{%-     else %}
{%-   endmatch %}
{%- endfor %}
}

{%- include "StringHelper.cpp" %}
{%- include "ObjectHelper.cpp" %}

// Methods calling directly into the uniffi generated C API of the Rust crate.
{%- for func in ci.iter_ffi_functions_js_to_rust() %}
{% call cpp::rust_fn_caller(module_name, func) %}
{%- endfor %}

{%- for func in ci.iter_ffi_functions_init_callback() %}
{% call cpp::callback_init(module_name, func) %}
{%- endfor %}

{%- import "macros.cpp" as cpp %}
